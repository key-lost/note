# 1 中间人代理mitmproxy
## 1.1 参考
- [mitmproxy教程(转载) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/371209542?utm_id=0)
- [手机app数据的爬取之mitmproxy安装教程_wx5bbc67ce7b2af的技术博客_51CTO博客](https://blog.51cto.com/u_14011026/6444525)
- [python结合mitmproxy抓包实践_python mitmproxy_random numbers的博客-CSDN博客](https://blog.csdn.net/shadow20112011/article/details/101232737?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-101232737-blog-120648395.235%5Ev38%5Epc_relevant_sort&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-101232737-blog-120648395.235%5Ev38%5Epc_relevant_sort&utm_relevant_index=8)
- [Windows 10 Edge浏览器无法访问localhost,127.0.0.1等本地地址的方法_http://127.0.0.1:5244 无法登录_白菜1031的博客-CSDN博客](https://blog.csdn.net/qq_16885135/article/details/52605801)
## 1.2 命令使用
1. 使用pip3 install mitmproxy安卓可以拥有`mitmproxy`、`mitmdump`      、`mitmweb` 三个命令和Python的定制包，去官网下载只会得到工具
2. 执行命令抓包会监听8080端口，所以需将127.0.0.1:8080设置为代理
	- 只是需要抓浏览器的包，可通过
	`C:\Program Files (x86)\Google\Chrome\Application\chrome.exe" --proxy-server=127.0.0.1:8080 --ignore-certificate-errors`启动浏览器即可抓包
	
	 - pc端（win10）抓包，打开设置》网络和Internet》代理》手动设置代理，地址填127.0.0.1，端口填8080，打开使用代理服务器的开关，点击保存即可
		![[Pasted image 20230908110936.png]]
	 - Android端（真机/模拟器i）和配置charles+ Postern抓包类似
		 - 下载postern，配置规则和代理，详见[环境配置](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%2F%E5%9F%BA%E7%A1%80%2F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE)1.4.2
		 - 下载mitmproxy证书并在Android端安装，下载证书需启动mitmproxy命令，用代理（127.0.0.1:8080）启动浏览器，详见pc端设置代理的方法，下图采用的是下载代理服务器的方式
			1.打开代理服务器，终端执行mitmproxy命令 ![[Pasted image 20230908111045.png]]
			2.访问[mitm.it](http://mitm.it/)即可下载证书，每台电脑上的mitmproxy对应一个证书，所以用别人的证书没有用
			![[Pasted image 20230908111443.png]]
			3.pc端下载证书可以访问https，双击证书一直点下一步就可以，Android端用自带的证书安装程序即可
1. mitmproxy命令可提供一个命令行界面实时获取请求，并通过命令筛选请求![[Pasted image 20230907164817.png]]
2. mitmweb命令会打开一个网页，通过gui交互过滤请求 ![[Pasted image 20230907164942.png]]
## 2.2 Python代码调用
### 2.2.1. 通过函数调用
```
import mitmproxy.http  
from mitmproxy import ctx  
  
num = 0  
  
  
def request(flow: mitmproxy.http.HTTPFlow):  
    global num  
    num = num + 1  
    ctx.log.info("We've seen %d flows" % num)
```
### 2.2.2. 类调用
- 函数为addons为列表，定义的各种类必须放入才能被执行到
```
import mitmproxy.http
from mitmproxy import ctx
import json

filter_host='www.iesdouyin.com' #目标主机
url_paths='/web/api/v2/aweme/post/?user_id=' # 网页 路径指纹


class Counter:
    def __init__(self):
        self.num = 0
    def request(self, flow: mitmproxy.http.HTTPFlow):
        global filter_host,url_paths
        if flow.request.host != filter_host or not flow.request.path.startswith(url_paths):
            return
        self.num = self.num + 1
        ctx.log.info("We've seen %d flows" % self.num)

class Joker:
    def request(self, flow: mitmproxy.http.HTTPFlow):
        pass
    def response(self, flow: mitmproxy.http.HTTPFlow):
        global filter_host,url_paths
        if flow.request.host != filter_host or not flow.request.path.startswith(url_paths):
            return
        text = flow.response.get_text()
        texts = self.deal_content(text)
        if not texts:
            print('null')
            return
        for a,b in texts:
            print(a)
            print(b)
            print('\n')
    def deal_content(self, a):
        b=json.loads(a)
        c=b.get('aweme_list')
        if not c:#c --> list of dicts
            return ''
        print('Found {} results.\n'.format(len(c)))
        rst=[]
        for i in c:
            j=i['statistics']
            info='播放次数:{} 评论数:{} 分享:{} 转发:{} 挖掘:{}'.format(j['play_count'],j['comment_count'],j['share_count'],j['forward_count'],j['digg_count'])
            #k=i['video']['download_addr']['url_list']
            #k=i['video']['play_addr_lowbr']['url_list']
            k=i['video']['play_addr']['url_list']
            ll='\n'.join(k)
            rst.append((info,ll))
        return rst

addons = [
    Counter(),
    Joker(),
]
```
### 2.2.3 代码执行 
- 代码完成之后，使用`mitmweb -s xxx.py`执行代码，保证代理是没问题的否则抓不到包
# 2 FridaHook辅助算法分析
## 2.1 作用
1. 找到一些疑似关键函数，可以通过hook来确认app执行某个操作的时候，是否调用了它们

2. 如果没有触发这些函数，考虑以下问题
    -  app在执行这个操作的时候，真的没有调用这个函数，换一个其他的关键函数
    - 代码写错了，导致hook函数没执行
    -  一般可以通过主动调用上层函数，来触发这些hook函数
3. 如果触发了这些函数，可以通过hook来打印执行过程中传入函数的参数和返回值
4. frida -U -F -l HookDemo.js
    - -U 代表远程USB设备
    - -F 代表附加到最前的这个app
    - -l 后面指明需要加载的JS脚本

5. 写好的js脚本要注入手机端，并不是在Node.js中使用，所以只能用v8和fridaAPI支持的代码
# 3 关键代码快速定位
1. HashMap的put方法
```
	 var hashMap = Java.use("java.util.HashMap");
    hashMap.put.implementation = function (a, b) {
        if(a.equals("username")){
            showStacks();
            console.log("hashMap.put: ", a, b);
        }
        return this.put(a, b);
    }
```
 1. ArrayList的add、addAll、set方法等
```
	var arrayList = Java.use("java.util.ArrayList");
	arrayList.add.overload('java.lang.Object').implementation = function (a) {
	   if(a.equals("username=15968079477")){
        showStacks();
        console.log("arrayList.add: ", a);
	    }
    //console.log("arrayList.add: ", a);
    return this.add(a);
	}
	arrayList.add.overload('int', 'java.lang.Object').implementation = function (a, b) {
    console.log("arrayList.add: ", a, b);
    return this.add(a, b);
	}

```
# 4 frida相关api详解